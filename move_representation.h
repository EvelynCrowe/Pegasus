//
// Created by troyl on 11/6/2019.
//

#ifndef PEGASUS_STUFF_MOVE_REPRESENTATION_H
#define PEGASUS_STUFF_MOVE_REPRESENTATION_H

#include <stdlib.h>
#include <iostream>
#include <cstdint>

typedef uint32_t UL;

namespace MoveRepresentation {

    class Move {
        // Array to store the ranges of bits each value takes up, index the UL long like an array (first bit from left is index 0)
        // As normal, range is (start, end] (not including end index)
            //castle: 0: no castle, 1: queen side, 2: king side
        //TODO: Increase ranges to accomadate the 120 possible spots?
        enum : unsigned char {startPosIndex, endPosIndex, castleIndex, enPassantIndex, captureIndex, promoteIndex, pieceThatMovedIndex};
        constexpr const static unsigned short ranges[7][2] = {{28u, 32u}, {24u, 28u}, {22u, 24u}, {18u, 22u}, {15u, 18u}, {12u, 15u}, {9u, 12u}};

        private:
            UL code; // Move object is a just a UL with some methods
        public:
            // Takes in inputs and returns a 32-bit number representing the move
            Move(short startPosition, short endPosition, short castle, short enPassant, short capturedPiece, short promotedPiece, short piece) {
                code = 0;
                UL numBits = sizeof(UL) * 8;
                std::cout << numBits << "\n";

                // Get result by bit-shifting the inputs into place then or'ing the results
                code |= (startPosition << (numBits - ranges[startPosIndex][1]));
                code |= (endPosition << (numBits - ranges[endPosIndex][1]));
                code |= (castle << (numBits - ranges[castleIndex][1]));
                code |= (enPassant << (numBits - ranges[enPassantIndex][1]));
                code |= (capturedPiece << (numBits - ranges[captureIndex][1]));
                code |= (promotedPiece << (numBits - ranges[promoteIndex][1]));
                code |= (piece << (numBits - ranges[pieceThatMovedIndex][1]));
            }

            // Generic decoder function, decodes "target" from "toDecode"
            // Meant to use MoveRepresentation::"enum" as "target"
            UL decodeItem(unsigned short target){
                UL numBits = sizeof(UL) * 8;
                // Use bit operations to extract "len" bits starting from right-most bit "right"
                // Bit mask generated by shifting 1 to the left, then subtracting 1, then shifting: ex: 0000 0001 -> 0001 0000 -> 0000 1111 -> 0111 1000
                return ((1u << (ranges[target][1] - ranges[target][0])) - 1u) & (code >> (numBits - ranges[target][1]));
            }
    };


//    // Decodes a string representation longo an array of its parts
//    static UL* decodeMove(UL toDecode){
//        UL numBits = sizeof(UL) * 8;
////        auto *results = (UL *) calloc(sizeof(ranges)/ sizeof(ranges[0]),(numBits) * 1000);
////        auto *results = new UL[sizeof(ranges)/ sizeof(ranges[0])];
////        UL* results = NULL;
////        results = new UL[sizeof(ranges)/ sizeof(ranges[0])];
//        UL results[sizeof(ranges)/ sizeof(ranges[0])];
////        std::cout << sizeof(ranges) << "\n";
////        std::cout << sizeof(ranges[0]) << "\n";
//        std::cout << sizeof(ranges)/ sizeof(ranges[0]) << "\n";
//        std::cout << sizeof(results) << "\n";
//        std::cout << sizeof(results)/ sizeof(results[0]) << "\n";
//
//        // Use bit operations to extract "len" bits starting from right-most bit "right"
//        // Bit mask generated by shifting 1 to the left, then subtracting 1, then shifting: ex: 0000 0001 -> 0001 0000 -> 0000 1111 -> 0111 1000
//        results[startPos] = decodeStartPos(toDecode);
//        results[endPos] = decodeEndPos(toDecode);
//        results[castle] = decodeCastle(toDecode);
//        results[enPassant] = decodeEnPassant(toDecode);
//        results[capture] = decodeCapturedPiece(toDecode);
//        results[promote] = decodePromotedPiece(toDecode);
//
//        return results;
//    }
};

#endif //PEGASUS_STUFF_MOVE_REPRESENTATION_H
