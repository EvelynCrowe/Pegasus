#ifndef PEGASUS_STUFF_MOVE_REPRESENTATION_H
#define PEGASUS_STUFF_MOVE_REPRESENTATION_H

#include <stdlib.h>
#include <iostream>
#include <cstdint>
#include <array>

#include "board_object.h"

typedef uint32_t UL;
typedef uint32_t Move;

//---------- Position constants ---------//
// Corners of the board
#define ROOK_B_SHORT_CORNER 98 // h8
#define ROOK_B_LONG_CORNER 91 // a8
#define ROOK_W_SHORT_CORNER 28 // h1
#define ROOK_W_LONG_CORNER 21 // a1

// Castling constants
#define ROOK_B_SHORT_CASTLE_TO 96 // f8
#define ROOK_B_LONG_CASTLE_TO 94 // d8
#define ROOK_W_SHORT_CASTLE_TO 26 // f1
#define ROOK_W_LONG_CASTLE_TO 24 // d1

//FIXME: this is a awful and long namespace, any recomendations for something shorter?
namespace MoveRepresentation {
//    enum : unsigned char {NO_CASTLE, LONG_CASTLE, SHORT_CASTLE};

    // Array to store the ranges of bits each value takes up, index the UL long like an array (first bit from left is index 0)
    // Start/endpos are out of 64
    // As normal, range is [start, end) (not including end index)
    // castle: 0: no castle, 1: queen side, 2: king side
    // EnPassant: 0 is none, 1 is there
    // Promote: which piece promote to
        // TODO: make new enum for promote
    //TODO: Increase ranges to accomadate the 120 possible spots?
    enum : unsigned char {startPosIndex /*6 bits*/, endPosIndex /*6 bits*/,
    castleIndex /*2 bits*/, enPassantIndex /*1 bits*/, captureIndex /*4 bits*/,
    promoteIndex /*1 bits*/, pieceThatMovedIndex /*4 bits*/};
    // Redid this so its easier to work with lol
    constexpr const static unsigned short widths[7] = {6, 6,
                                                       2, 1, 4,
                                                       1, 4};
    // Automatically calculated for speed
    static unsigned short prefixRanges[sizeof(widths)/ sizeof(widths[0])];

//    constexpr const static unsigned short ranges[7][2] = {{32u-6u, 32u}, {32u-12u, 32u-6u},
//    {32u-14u, 32u-12u}, {32u-15u, 32u-14u}, {32u-18u, 32u-15u},
//    {32u-19u, 32u-18u}, {32u-22u, 32u-19u}};

    // Changelog: changed piece that moved and capture to 4 bits so it can use the piece enum found in board.h for compatibility/speed and since there is extra space anyways
    //            changed ranges so that it looks nicer an is easier to work with lol
    //            finalized the rules of each bit and what they each stand for:     v v v v v SEE BELOW v v v v v

    /**
     * Creates a new move given the parameters.
     * Required parameters: 
     *   <start/end>Position: 64-index of the moving piece (castling is done by a king move)
     *   pieceThatMoved: colored piece that is making the move
     * Optional parameters:
     *   castle: 0 = no castle, 1 = castle, can determine which side by start/end position
     *   enPassant: 0 = no enPassant, 1 = enPassant(either the capture or the initial forward 2 jump), can determine btw them by checking whether capture is empty or not, since the jump forward 2 cannot capture
     *   capture: the colored piece that was captured during this move
     *   promote: 0 = no promote, 1 = promote. If 1, pieceThatMoved will contain what it promoted to, can be assumed it WAS a pawn cuz only pawns promote
     */
    Move encodeMove(short startPosition, short endPosition, short piece, 
    short capturedPiece=board::EMPTY, short castle=0u, short enPassant=0u, short promotedPiece=board::EMPTY) {
        Move code = 0;
        UL numBits = sizeof(UL) * 8;

        // calculate prefixRanges, should run only once
        if (prefixRanges == nullptr){
            prefixRanges[0] = widths[0];
            for(int i = 0; i < sizeof(widths)/ sizeof(widths[0]); i++){
                prefixRanges[i] = prefixRanges[i-1] + widths[i];
            }
        }

        // Get result by bit-shifting the inputs into place then or'ing the results
        code |= (startPosition << (numBits - prefixRanges[startPosIndex]));
        code |= (endPosition << (numBits - prefixRanges[endPosIndex]));
        code |= (castle << (numBits - prefixRanges[castleIndex]));
        code |= (enPassant << (numBits - prefixRanges[enPassantIndex]));
        code |= (capturedPiece << (numBits - prefixRanges[captureIndex]));
        code |= (promotedPiece << (numBits - prefixRanges[promoteIndex]));
        code |= (piece << (numBits - prefixRanges[pieceThatMovedIndex]));

        return code;
    }

    // Generic decoder function, decodes "target" from "toDecode"
    // Meant to use MoveRepresentation::"enum" as "target"
    UL decodeMove(Move code, unsigned short target){
        UL numBits = sizeof(UL) * 8;
        // Use bit operations to extract "len" bits starting from right-most bit "right"
        // Bit mask generated by shifting 1 to the left, then subtracting 1, then shifting: ex: 0000 0001 -> 0001 0000 -> 0000 1111 -> 0111 1000
        return ((1u << (prefixRanges[target] - ((target == 0) ? 0 : prefixRanges[target-1])) ) - 1u) & (code >> (numBits - prefixRanges[target]));
    }

    // TODO: should applyMove and undoMove be placed here? I feel like it'd be better to put it elsewhere
    /** 
     * Returns true if it was able to apply move to the board, 
     * Assumes move is valid.
     */
    bool applyMove(board::Board *board, Move move) {
        // store endpos since we will use it multiple times, and it does not make sense to repeatedly recalculate it
        UL endPos = decodeMove(move, endPosIndex);
        UL startPos = decodeMove(move, startPosIndex);

        /*----- set END of move ------*/
        // assumes promoteIndex stores piece type being promoted to, EMPTY/INVALID otherwise
        if (decodeMove(move, promoteIndex) == utility::uncolor(board::INVALID)) {
            // normal move
            board->chessboard[endPos] = board->chessboard[startPos];
        } else {
            // promotion
            if (utility::isWhite(board->chessboard[startPos])) // TODO: eww can we just store whose turn it is?
                board->chessboard[endPos] = utility::recolor(decodeMove(move, promoteIndex));
            else
                board->chessboard[endPos] = utility::toBlack(utility::recolor(decodeMove(move, promoteIndex)));
        }

        /*----- en passant ------*/
        // assumes 0 means not en passant, anything else means en passant
        if (decodeMove(move, enPassantIndex)) {
            // assumes 12x10 board, where 10 in a row. 
            // row of start and column of end
            board->chessboard[startPos/10*10 + endPos%10] = board::EMPTY;
        }

        /*----- castling ------*/
        // set rook for short castle
        if (decodeMove(move, castleIndex) == SHORT_CASTLE) {
            // is this on black or white's side?
            if (endPos > 32) { // Regardless if we use 120 or 64 position numbering, 32 will be between ranks [2,7] inclusive. Could be any other number that fits this criteria.
                board->chessboard[ROOK_B_SHORT_CORNER] = board::EMPTY;
                board->chessboard[ROOK_B_SHORT_CASTLE_TO] = board::BR;
            } else {
                board->chessboard[ROOK_W_SHORT_CORNER] = board::EMPTY;
                board->chessboard[ROOK_W_SHORT_CASTLE_TO] = board::WR;
            }
        // set rook for long castle
        } else if (decodeMove(move, castleIndex) == LONG_CASTLE) {
            // is this on black or white's side?
            if (endPos > 32) { // Regardless if we use 120 or 64 position numbering, 32 will be between ranks [2,7] inclusive. Could be any other number that fits this criteria.
                board->chessboard[ROOK_B_LONG_CORNER] = board::EMPTY;
                board->chessboard[ROOK_B_LONG_CASTLE_TO] = board::BR;
            } else {
                board->chessboard[ROOK_W_LONG_CORNER] = board::EMPTY;
                board->chessboard[ROOK_W_LONG_CASTLE_TO] = board::WR;
            }
        }

        /*----- set START of move ------*/
        // move from will always leave an empty space (except chess960 castling, which is handled in castling section)
        board->chessboard[startPos] = board::EMPTY;
        return true;
    }

    bool undoMove(board::Board *board, Move move) {
        // store endpos since we will use it multiple times, and it does not make sense to repeatedly recalculate it
        UL endPos = decodeMove(move, endPosIndex);
        UL startPos = decodeMove(move, startPosIndex);

        /*----- reset START of move ------*/
        // assumes promoteIndex stores piece type being promoted to, EMPTY/INVALID otherwise
        if (decodeMove(move, promoteIndex) == utility::uncolor(board::INVALID)) {
            board->chessboard[startPos] = board->chessboard[endPos];
        } else {
            // promotion can only come from a pawn of its color
            board->chessboard[startPos] = utility::isWhite(board->chessboard[endPos]) ? board::WP : board::BP;
        }
        // from this point on, we can be sure the piece that made the move is the one at start position

        /*----- set END of move ------*/
        // replace the piece that was captured,
        board->chessboard[endPos] = utility::recolor(decodeMove(move, captureIndex));
        // and recolor it if needed
        if (utility::isBlack(board->chessboard[startPos])) utility::toBlack(board->chessboard[endPos]);

        /*----- en passant ------*/
        // assumes 0 means not en passant, anything else means en passant
        if (decodeMove(move, enPassantIndex)) {
            // assumes 12x10 board, where 10 in a row. 
            // row of start and column of end
            board->chessboard[startPos/10*10 + endPos%10] = utility::isWhite(board->chessboard[startPos]) ? board::WP : board::BP;
        }

        /*----- castling ------*/
        // set rook for short castle
        if (decodeMove(move, castleIndex) == SHORT_CASTLE) {
            // is this on black or white's side?
            if (endPos > 32) { // Regardless if we use 120 or 64 position numbering, 32 will be between ranks [2,7] inclusive. Could be any other number that fits this criteria.
                board->chessboard[ROOK_B_SHORT_CORNER] = board::BR;
                board->chessboard[ROOK_B_SHORT_CASTLE_TO] = board::EMPTY;
            } else {
                board->chessboard[ROOK_W_SHORT_CORNER] = board::WR;
                board->chessboard[ROOK_W_SHORT_CASTLE_TO] = board::EMPTY;
            }
        // set rook for long castle
        } else if (decodeMove(move, castleIndex) == LONG_CASTLE) {
            // is this on black or white's side?
            if (endPos > 32) { // Regardless if we use 120 or 64 position numbering, 32 will be between ranks [2,7] inclusive. Could be any other number that fits this criteria.
                board->chessboard[ROOK_B_LONG_CORNER] = board::BR;
                board->chessboard[ROOK_B_LONG_CASTLE_TO] = board::EMPTY;
            } else {
                board->chessboard[ROOK_W_LONG_CORNER] = board::WR;
                board->chessboard[ROOK_W_LONG_CASTLE_TO] = board::EMPTY;
            }
        }
        return true;
    }

//    // Decodes a string representation longo an array of its parts
//    static UL* decodeMove(UL toDecode){
//        UL numBits = sizeof(UL) * 8;
////        auto *results = (UL *) calloc(sizeof(ranges)/ sizeof(ranges[0]),(numBits) * 1000);
////        auto *results = new UL[sizeof(ranges)/ sizeof(ranges[0])];
////        UL* results = NULL;
////        results = new UL[sizeof(ranges)/ sizeof(ranges[0])];
//        UL results[sizeof(ranges)/ sizeof(ranges[0])];
////        std::cout << sizeof(ranges) << "\n";
////        std::cout << sizeof(ranges[0]) << "\n";
//        std::cout << sizeof(ranges)/ sizeof(ranges[0]) << "\n";
//        std::cout << sizeof(results) << "\n";
//        std::cout << sizeof(results)/ sizeof(results[0]) << "\n";
//
//        // Use bit operations to extract "len" bits starting from right-most bit "right"
//        // Bit mask generated by shifting 1 to the left, then subtracting 1, then shifting: ex: 0000 0001 -> 0001 0000 -> 0000 1111 -> 0111 1000
//        results[startPos] = decodeStartPos(toDecode);
//        results[endPos] = decodeEndPos(toDecode);
//        results[castle] = decodeCastle(toDecode);
//        results[enPassant] = decodeEnPassant(toDecode);
//        results[capture] = decodeCapturedPiece(toDecode);
//        results[promote] = decodePromotedPiece(toDecode);
//
//        return results;
//    }
};

#endif //PEGASUS_STUFF_MOVE_REPRESENTATION_H
